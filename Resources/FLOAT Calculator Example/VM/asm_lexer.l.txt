/* $Id: asm_lexer.l,v 1.37 2023/11/12 20:30:47 leavens Exp $ */
/* Scanner for the SRM Assembly Language */

%option header-file = "asm_lexer.h"
%option outfile = "asm_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>
#include <assert.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"
#include "lexer_utilities.h"

 /* Tokens generated by Bison */
#include "asm.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* Have any errors been noted? */
bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    assert(filename != NULL);
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void reg2ast(const char *txt) {
    AST t;
    assert(filename != NULL);
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.text = strdup(yytext);
    unsigned short n;
    sscanf(txt, "%hd", &n);
    t.reg.number = n;
    yylval = t;
}

static void namedreg2ast(unsigned short num, const char *txt) {
    AST t;
    assert(filename != NULL);
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.text = strdup(yytext);
    t.reg.number = num;
    yylval = t;
}


static void ident2ast(const char *name) {
    AST t;
    assert(filename != NULL);
    t.ident.file_loc = file_location_make(filename, yylineno);
    assert(t.ident.file_loc != NULL);
    assert(t.ident.file_loc->filename != NULL);
    t.ident.name = strdup(name);
    yylval = t;
}

static void unsignedint2ast(unsigned int val)
{
    AST t;
    assert(filename != NULL);
    t.unsigned_int.file_loc = file_location_make(filename, yylineno);
    assert(t.unsigned_int.file_loc != NULL);
    assert(t.unsigned_int.file_loc->filename != NULL);
    t.unsigned_int.text = strdup(yytext);
    t.unsigned_int.value = val;
    yylval = t;
}

static void signedint2ast(int val)
{
    AST t;
    assert(filename != NULL);
    t.signed_int.file_loc = file_location_make(filename, yylineno);
    t.signed_int.text = strdup(yytext);
    t.signed_int.value = val;
    yylval = t;
}

static void float2ast(float_type val)
{
    AST t;
    t.floatlit.file_loc = file_location_make(filename, yylineno);
    t.floatlit.text = strdup(yytext);
    t.floatlit.value = val;
    yylval = t;
}

static unsigned int uIntLitValue(const char *text, unsigned int leng)
{
    unsigned int val;
    int ssf_ret;
    if (leng >= 2 && (strncmp(text, "0x", 2) == 0)) {
	// hex literal
	if ((leng-2) > 2*BYTES_PER_WORD) {
            formatted_yyerror(lexer_filename(),
			      "Hexadecimal literal (%s) is too big for a word!",
			      text);
	}
	ssf_ret = sscanf(text+2, "%xt", &val);
	if (ssf_ret != 1) {
            formatted_yyerror(lexer_filename(),
	                      "Unsigned hex literal (%s) could not be read by lexer!",
			      text);
	}
    } else {
	// decimal literal
	if (leng > 10) {
            formatted_yyerror(lexer_filename(),
			      "Unsigned int literal (%s) is too big!",
			      text);
	}
	ssf_ret = sscanf(text, "%ut", &val);
	if (ssf_ret != 1) {
	    bail_with_error("Unsigned decimal literal (%s) could not be read by lexer!",
			    text);
	}
    }
    return val;
}

%}

 /* you can add actual definitions below */

DECDIGIT	[0-9]
UNSIGNEDINTLIT  (((0x)[0-9A-Fa-f]+)|{DECDIGIT}+)
SIGN            (-|\+)
EXPONENTMARKER  [eE]
MANTISSA        [.]({DECDIGIT})*
FNUMBERPART     {SIGN}?{DECDIGIT}+{MANTISSA}?
EXPONENTPART    {EXPONENTMARKER}{SIGN}?{DECDIGIT}+
FLOATLIT        {FNUMBERPART}{EXPONENTPART}?

LETTER		[_a-zA-Z]
LETTERORDIGIT	({LETTER}|{DECDIGIT})
IDENT		{LETTER}({LETTERORDIGIT}*)
NEWLINE         \n
CR              \r
EOL             ({NEWLINE}|({CR}{NEWLINE}))
COMMENTSTART    #
COMMENT         {COMMENTSTART}.*
IGNORED         [ \t\v\f\r]

  /* states of the lexer */

%s INSTRUCTION
%s DATADECL

%%

{IGNORED}       { ; } /* do nothing */
{COMMENT}       { ; } /* ignore comments */
<INSTRUCTION>{EOL} { BEGIN INITIAL; return eolsym; }
<DATADECL>{EOL} { BEGIN INITIAL; return eolsym; }
{EOL}           { ; } /* ignore EOL outside of the above states */

ADD             { BEGIN INSTRUCTION; tok2ast(addopsym); return addopsym; }
SUB             { BEGIN INSTRUCTION; tok2ast(subopsym); return subopsym; }
AND             { BEGIN INSTRUCTION; tok2ast(andopsym); return andopsym; }
BOR             { BEGIN INSTRUCTION; tok2ast(boropsym); return boropsym; }
NOR             { BEGIN INSTRUCTION; tok2ast(noropsym); return noropsym; }
XOR             { BEGIN INSTRUCTION; tok2ast(xoropsym); return xoropsym; }
MUL             { BEGIN INSTRUCTION; tok2ast(mulopsym); return mulopsym; }
DIV             { BEGIN INSTRUCTION; tok2ast(divopsym); return divopsym; }
FADD            { BEGIN INSTRUCTION; tok2ast(faddopsym); return faddopsym; }
FSUB            { BEGIN INSTRUCTION; tok2ast(fsubopsym); return fsubopsym; }
FMUL            { BEGIN INSTRUCTION; tok2ast(fmulopsym); return fmulopsym; }
FDIV            { BEGIN INSTRUCTION; tok2ast(fdivopsym); return fdivopsym; }
SLL             { BEGIN INSTRUCTION; tok2ast(sllopsym); return sllopsym; }
SRL             { BEGIN INSTRUCTION; tok2ast(srlopsym); return srlopsym; }
MFHI            { BEGIN INSTRUCTION; tok2ast(mfhiopsym); return mfhiopsym; }
MFLO            { BEGIN INSTRUCTION; tok2ast(mfloopsym); return mfloopsym; }
CVT             { BEGIN INSTRUCTION; tok2ast(cvtopsym); return cvtopsym; }
RND             { BEGIN INSTRUCTION; tok2ast(rndopsym); return rndopsym; }
JR              { BEGIN INSTRUCTION; tok2ast(jropsym); return jropsym; }
ADDI            { BEGIN INSTRUCTION; tok2ast(addiopsym); return addiopsym; }
ANDI            { BEGIN INSTRUCTION; tok2ast(andiopsym); return andiopsym; }
BORI            { BEGIN INSTRUCTION; tok2ast(boriopsym); return boriopsym; }
XORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return xoriopsym; }
BEQ             { BEGIN INSTRUCTION; tok2ast(beqopsym); return beqopsym; }
BGEZ            { BEGIN INSTRUCTION; tok2ast(bgezopsym); return bgezopsym; }
BLEZ            { BEGIN INSTRUCTION; tok2ast(blezopsym); return blezopsym; }
BGTZ            { BEGIN INSTRUCTION; tok2ast(bgtzopsym); return bgtzopsym; }
BLTZ            { BEGIN INSTRUCTION; tok2ast(bltzopsym); return bltzopsym; }
BNE             { BEGIN INSTRUCTION; tok2ast(bneopsym); return bneopsym; }
BFEQ            { BEGIN INSTRUCTION; tok2ast(bfeqopsym); return bfeqopsym; }
BFGEZ           { BEGIN INSTRUCTION; tok2ast(bfgezopsym); return bfgezopsym; }
BFLEZ           { BEGIN INSTRUCTION; tok2ast(bflezopsym); return bflezopsym; }
BFGTZ           { BEGIN INSTRUCTION; tok2ast(bfgtzopsym); return bfgtzopsym; }
BFLTZ           { BEGIN INSTRUCTION; tok2ast(bfltzopsym); return bfltzopsym; }
BFNE            { BEGIN INSTRUCTION; tok2ast(bfneopsym); return bfneopsym; }
LBU             { BEGIN INSTRUCTION; tok2ast(lbuopsym); return lbuopsym; }
FLW             { BEGIN INSTRUCTION; tok2ast(flwopsym); return flwopsym; }
LW              { BEGIN INSTRUCTION; tok2ast(lwopsym); return lwopsym; }
SB              { BEGIN INSTRUCTION; tok2ast(sbopsym); return sbopsym; }
FSW             { BEGIN INSTRUCTION; tok2ast(fswopsym); return fswopsym; }
SW              { BEGIN INSTRUCTION; tok2ast(swopsym); return swopsym; }
JMP             { BEGIN INSTRUCTION; tok2ast(jmpopsym); return jmpopsym; }
JAL             { BEGIN INSTRUCTION; tok2ast(jalopsym); return jalopsym; }
EXIT            { BEGIN INSTRUCTION; tok2ast(exitopsym); return exitopsym; }
PSTR            { BEGIN INSTRUCTION; tok2ast(pstropsym); return pstropsym; }
PINT            { BEGIN INSTRUCTION; tok2ast(pintopsym); return pintopsym; }
PFLT            { BEGIN INSTRUCTION; tok2ast(pfltopsym); return pfltopsym; }
PCH             { BEGIN INSTRUCTION; tok2ast(pchopsym); return pchopsym; }
RCH             { BEGIN INSTRUCTION; tok2ast(rchopsym); return rchopsym; }
RFLT            { BEGIN INSTRUCTION; tok2ast(rfltopsym); return rfltopsym; }
STRA            { BEGIN INSTRUCTION; tok2ast(straopsym); return straopsym; }
NOTR            { BEGIN INSTRUCTION; tok2ast(notropsym); return notropsym; }

INT             { BEGIN DATADECL; tok2ast(intsym); return intsym; }
FLOAT           { BEGIN DATADECL; tok2ast(floatsym); return floatsym; }

\+              { tok2ast(plussym); return plussym; }
-               { tok2ast(minussym); return minussym; }
,               { return commasym; }

\.text          { tok2ast(dottextsym); return dottextsym; }
\.data          { tok2ast(dotdatasym); return dotdatasym; }
\.stack         { tok2ast(dotstacksym); return dotstacksym; }
\.end           { return dotendsym; }
\=              { tok2ast(equalsym); return equalsym; }
:               { return colonsym; }

{SIGN}{UNSIGNEDINTLIT} { const char *filename = lexer_filename();
                         unsigned int uval = uIntLitValue(yytext+1, yyleng-1);
                         if (uval > INT_MAX && yytext[0] == '+') {
                             formatted_yyerror(filename,
  		                 "Signed int literal value (%s) is too big for a 32-bit integer!",
				 yytext);
			 } else if (uval - 1 > INT_MAX && yytext[0] == '-') {
	                     formatted_yyerror(filename,
                                 "Signed int literal value (%s) is too big for a 32-bit integer!",
				 yytext);
			 }
			 int val;
			 int ssf_ret;
			 // scan it with the sign included
			 ssf_ret = sscanf(yytext, "%d", &val);
			 signedint2ast(val);
			 return signedintsym;
                       }

{UNSIGNEDINTLIT} { unsigned int val = uIntLitValue(yytext, yyleng);
                   unsignedint2ast(val);
                   return unsignedintsym; 
                 }

{FLOATLIT}      { float val;
                  int ssf_ret;
		  ssf_ret = sscanf(yytext, "%f", &val);
		  if (ssf_ret != 1) {
		      bail_with_error("Float literal (%s) could not be read by lexer!",
				      yytext);
                  }
                  float2ast(val);
		  return floatlitsym;
                }

${DECDIGIT}{1,2} { reg2ast(yytext+1); return regsym; }
$at             { namedreg2ast(1,yytext); return regsym; }
$v0             { namedreg2ast(2,yytext); return regsym; }
$v1             { namedreg2ast(3,yytext); return regsym; }
$a0             { namedreg2ast(4,yytext); return regsym; }
$a1             { namedreg2ast(5,yytext); return regsym; }
$a2             { namedreg2ast(6,yytext); return regsym; }
$a3             { namedreg2ast(7,yytext); return regsym; }
$t0             { namedreg2ast(8,yytext); return regsym; }
$t1             { namedreg2ast(9,yytext); return regsym; }
$t2             { namedreg2ast(10,yytext); return regsym; }
$t3             { namedreg2ast(11,yytext); return regsym; }
$t4             { namedreg2ast(12,yytext); return regsym; }
$t5             { namedreg2ast(13,yytext); return regsym; }
$t6             { namedreg2ast(14,yytext); return regsym; }
$t7             { namedreg2ast(15,yytext); return regsym; }
$s0             { namedreg2ast(16,yytext); return regsym; }
$s1             { namedreg2ast(17,yytext); return regsym; }
$s2             { namedreg2ast(18,yytext); return regsym; }
$s3             { namedreg2ast(19,yytext); return regsym; }
$s4             { namedreg2ast(20,yytext); return regsym; }
$s5             { namedreg2ast(21,yytext); return regsym; }
$s6             { namedreg2ast(22,yytext); return regsym; }
$s7             { namedreg2ast(23,yytext); return regsym; }
$t8             { namedreg2ast(24,yytext); return regsym; }
$t9             { namedreg2ast(25,yytext); return regsym; }
$gp             { namedreg2ast(28,yytext); return regsym; }
$sp             { namedreg2ast(29,yytext); return regsym; }
$fp             { namedreg2ast(30,yytext); return regsym; }
$ra             { namedreg2ast(31,yytext); return regsym; }

{IDENT}         { ident2ast(yytext); return identsym; }

.   { formatted_yyerror(lexer_filename(),
			"invalid character: '%c' ('\\0%o')",
			*yytext, *yytext);
    }
%%

/* Requires: fname != NULL
 * Requires: fname is the name of a readable file
 * Initialize the lexer and start it reading from the given file. */
void lexer_init(char *fname) {
   errors_noted = false;
   filename = fname;    
   yyin = fopen(fname, "r");
   if (yyin == NULL) {
       bail_with_error("Lexer cannot open %s", fname);
   }
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}

/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
	}
        if (t != eolsym) {
	    lexer_print_token(t, yylineno, yytext);
        } else {
	    lexer_print_token(t, yylineno, "\\n");
	}
    } while (t != YYEOF);
}
