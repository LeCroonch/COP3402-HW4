# $Id: Makefile,v 1.37 2023/11/28 22:29:26 leavens Exp leavens $
# Makefile for float calculator parser and static analysis

# Add .exe to the end of target to get that suffix in the rules
COMPILER = float
LEXER = ./float -l
UNPARSER = ./float -u
VM = vm
DISASM = $(VM)/disasm
RUNVM = $(VM)/$(VM)

# Tools used
CC = gcc
# on Linux, the following can be used with gcc:
# CFLAGS = -fsanitize=address -static-libasan -g -std=c17 -Wall
CFLAGS = -g -std=c17 -Wall
YACC = bison
YACCFLAGS = -Wall --locations -d -v
LEX = flex
LEXFLAGS =
# Unix command names
MV = mv
RM = rm -f
OVERALLZIPFILE = float-calculator.zip
ZIP = zip -9
FLOAT = float
SUF = flt
# Add the names of your own files with a .o suffix to link them in the program
# Feel free to edit the following definition of COMPILER_OBJECTS
COMPILER_OBJECTS = compiler_main.o $(FLOAT)_lexer.o \
		parser.o unparser.o id_use.o type_exp.o type_check.o \
		id_attrs.o ast.o $(FLOAT).tab.o file_location.o utilities.o \
		symtab.o scope.o scope_check.o lexer_utilities.o \
		instruction.o code.o gen_code.o literal_table.o \
	        bof.o machine_types.o regname.o

# different kinds of tests
ASTTESTS = asttest0.$(SUF) asttest1.$(SUF) asttest2.$(SUF) \
	asttest3.$(SUF) asttest4.$(SUF) asttest5.$(SUF)
PARSEERRTESTS = parseerrtest0.$(SUF) parseerrtest1.$(SUF) \
	parseerrtest2.$(SUF) parseerrtest3.$(SUF) parseerrtest4.$(SUF) \
	parseerrtest5.$(SUF) parseerrtest6.$(SUF) parseerrtest7.$(SUF) 
NONDECLTESTS = $(ASTTESTS) $(REGULARTESTS) $(ERRTESTS) $(PARSEERRTESTS)
VMTESTS = vmtest0.flt vmtest1.flt vmtest2.flt vmtest3.flt \
	vmtest4.flt vmtest5.flt vmtest6.flt vmtest7.flt vmtest8.flt
SCOPETESTS = vmtest-nesting0.$(SUF) vmtest-nesting1.$(SUF) \
	vmtest-nesting2.$(SUF) vmtest-nesting3.$(SUF) vmtest-nesting4.$(SUF) 
DECLERRTESTS = declerrtest0.$(SUF)  declerrtest1.$(SUF)  declerrtest2.$(SUF) \
	       declerrtest3.$(SUF) declerrtest4.$(SUF)  declerrtest5.$(SUF) \
	       declerrtest6.$(SUF)  declerrtest7.$(SUF)
DECLTESTS = $(SCOPETESTS) $(DECLERRTESTS)
GOODVMTESTS =  $(VMTESTS) $(SCOPETESTS)
GOODTESTS = $(ASTTESTS) $(GOODVMTESTS)
BADTESTS = $(PARSEERRTESTS) $(DECLERRTESTS)
# ALLTESTS is all of the test files, if you add more tests you can add to this list
ALLTESTS = $(NONDECLTESTS) $(DECLTESTS)
EXPECTEDOUTPUTS = $(ALLTESTS:.$(SUF)=.out)
# STUDENTESTOUTPUTS is all of the .myo files corresponding to the tests
# if you add more tests, you can add more to this list
STUDENTTESTOUTPUTS = $(ALLTESTS:.$(SUF)=.myo)

# create the VM executable
.PRECIOUS: $(VM)/$(VM)
$(VM): $(VM)/$(VM)

.DEFAULT: $(COMPILER)
.PHONY: compiler
compiler: $(COMPILER)

# create the VM executable
.PRECIOUS: $(VM)/$(VM)
$(VM): $(VM)/$(VM)

.PRECIOUS: $(FLOAT)_lexer.c
$(FLOAT)_lexer.c: $(FLOAT)_lexer.l
	$(LEX) $(FLOAT)_lexer.l

$(FLOAT)_lexer.o: $(FLOAT)_lexer.c
	$(CC) $(CFLAGS) -Wno-unused-but-set-variable -c $(FLOAT)_lexer.c

$(COMPILER): $(COMPILER_OBJECTS)
	$(CC) $(CFLAGS) -o $(COMPILER) $(COMPILER_OBJECTS)

$(COMPILER)_main.o: $(COMPILER)_main.c
	$(CC) $(CFLAGS) -c $<

$(FLOAT).tab.o: $(FLOAT).tab.c $(FLOAT).tab.h
	$(CC) $(CFLAGS) -c $<

$(FLOAT).tab.c $(FLOAT).tab.h: $(FLOAT).y ast.h parser_types.h machine_types.h 
	$(YACC) $(YACCFLAGS) $(FLOAT).y

$(FLOAT)_lexer.l: $(FLOAT).tab.h

# rule for compiling individual .c files
%.o: %.c %.h
	$(CC) $(CFLAGS) -c $<

.PHONY: clean
clean:
	$(RM) *~ *.o '#'*
	$(RM) $(FLOAT)_lexer.c $(FLOAT)_lexer.h
	$(RM) $(FLOAT).tab.c $(FLOAT).tab.h $(FLOAT).output
	$(RM) $(COMPILER).exe $(COMPILER)
	$(RM) *.stackdump core
	$(RM) $(SUBMISSIONZIPFILE)
	$(RM) *.log *.dvi* *.blg *.ilg

cleanall: clean
	$(RM) *.myo *.myto *.bof *.asm *.tout
	cd vm; make cleanall

# The .myo files are outputs of VM when run on compiled programs
# with no tracing in the VM (a high level output of the tests)
# The use of cat char-inputs.txt | allows read statments to not hang
.PRECIOUS: %.myo
%.myo: %.bof $(VM)
	$(RM) $@; umask 022; \
	cat char-inputs.txt | ./$(RUNVM) $< > $@ 2>&1

# The .myto files are outputs from running compiled programs
# with the VM's -t option (useful for debugging)
# The use of cat char-inputs.txt | allows read statments to not hang
.PRECIOUS: %.myto
%.myto: %.bof $(VM)
	$(RM) $@; umask 022; \
	cat char-inputs.txt | $(RUNVM) -t $< > $@ 2>&1

# The .bof files are the compiled binary object files.
.PRECIOUS: %.bof
%.bof: %.$(SUF) $(COMPILER)
	$(RM) $@; umask 022; \
	./$(COMPILER) $<

# The .asm files are disassembled binary object files.
# These are useful for debugging the code the compiler creates.
%.asm: %.bof $(DISASM)
	$(RM) $@; umask 022; \
	$(DISASM) $< > $@ 2>&1

# The .upo files are unparsed programs;
# these are useful for debugging the parser and understanding the parse.
%.upo: %.$(SUF) $(COMPILER)
	$(RM) $@; umask 022; \
	./$(UNPARSER) $< > $@ 2>&1

# main target for testing
.PHONY: check-outputs check-front-end-outputs check-vm-outputs
check-front-end-outputs: check-nondecl-outputs check-decl-outputs

check-outputs: check-vm-outputs

.PHONY: check-outputs check-nondecl-outputs check-decl-outputs
check-outputs: check-nondecl-outputs check-decl-outputs
	@echo 'Be sure to look for two test summaries above (nondeclaration and declaration tests)'

check-nondecl-outputs: $(COMPILER) $(NONDECLTESTS)
	@DIFFS=0; \
	for f in `echo $(NONDECLTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		echo running unparser on "$$f.$(SUF)"; \
		./$(UNPARSER) "$$f.$(SUF)" >"$$f.myo" 2>&1; \
		diff -w -B "$$f.out" "$$f.myo" && echo 'passed!' || DIFFS=1; \
	done; \
	if test 0 = $$DIFFS; \
	then \
		echo 'All nondeclaration tests passed!'; \
	else \
		echo 'Some nondeclaration test(s) failed!'; \
	fi

check-decl-outputs: $(COMPILER) $(DECLTESTS)
	@DIFFS=0; \
	for f in `echo $(DECLTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		echo running unparser on "$$f.$(SUF)"; \
		./$(UNPARSER) "$$f.$(SUF)" >"$$f.myo" 2>&1; \
		diff -w -B "$$f.out" "$$f.myo" && echo 'passed!' || DIFFS=1; \
	done; \
	if test 0 = $$DIFFS; \
	then \
		echo 'All declaration checking tests passed!'; \
	else \
		echo 'Some declaration checking test(s) failed!'; \
	fi

check-good-outputs: $(COMPILER) $(GOODTESTS)
	DIFFS=0; \
	for f in `echo $(GOODTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		$(RM) "$$f.myo" ; \
		./$(UNPARSER) $$f.$(SUF) >"$$f.myo" 2>&1; \
		diff -w -B "$$f.out" "$$f.myo" && echo 'passed!' || DIFFS=1; \
	done; \
	if test 0 = $$DIFFS; \
	then \
		echo 'All good output tests passed!'; \
	else \
		echo 'Test(s) failed!'; \
	fi

check-bad-outputs: $(COMPILER) $(BADTESTS)
	DIFFS=0; \
	for f in `echo $(BADTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		$(RM) "$$f.myo" ; \
		./$(UNPARSER) $$f.$(SUF) >"$$f.myo" 2>&1; \
		diff -w -B "$$f.out" "$$f.myo" && echo 'passed!' || DIFFS=1; \
	done; \
	if test 0 = $$DIFFS; \
	then \
		echo 'All bad output tests passed!'; \
	else \
		echo 'Test(s) failed!'; \
	fi

$(SUBMISSIONZIPFILE): *.c *.h $(STUDENTTESTOUTPUTS)
	$(ZIP) $(SUBMISSIONZIPFILE) $(FLOAT).y $(FLOAT)_lexer.l *.c *.h Makefile
	$(ZIP) $(SUBMISSIONZIPFILE) $(STUDENTTESTOUTPUTS) $(ALLTESTS) $(EXPECTEDOUTPUTS)

# developer's section below...

# The .out files are expected outputs from running the VM on
# the compiled program.
# The use of cat char-inputs.txt | allows read statments to not hang
.PRECIOUS: %.out
%.out: %.bof $(RUNVM)
	@if test '$(IMTHEINSTRUCTOR)' != true ; \
	then \
		echo 'Students should make the .myo target, not the .out target' ; \
		echo 'as making the .out files will invalidate the tests' ; \
		exit 1; \
	fi
	$(RM) $@; umask 022; \
	cat char-inputs.txt | $(RUNVM) $< >$@ 2>&1

%.tout: %.bof $(RUNVM)
	$(RM) $@; umask 022; \
	cat char-inputs.txt | $(RUNVM) -t $< >$@ 2>&1

.PHONY: create-outputs
create-outputs: $(COMPILER) $(ALLTESTS)

create-outputs: create-compiler-outputs

create-compiler-outputs: $(COMPILER) $(GOODVMTESTS)
	@if test '$(IMTHEINSTRUCTOR)' != true ; \
	then \
		echo 'Students should use the target check-compiler-outputs,' ; \
		echo 'as using this target (create-compiler-outputs) will invalidate the tests' ; \
		exit 1; \
	fi; \
	for f in `echo $(GOODVMTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		echo running ./$(COMPILER) on "$$f.$(SUF)"; \
		$(RM) "$$f.asm" "$$f.out"; \
		./$(COMPILER) "$$f.$(SUF)" ; \
		echo running $(DISASM) on "$$f.bof"; \
		$(DISASM) "$$f.bof" > "$$f.asm" 2>&1; \
		echo running $(RUNVM) on "$$f.bof"; \
		$(RUNVM) "$$f.bof" > "$$f.out" 2>&1; \
	done; \
	echo done creating compiler test outputs!

create-unparser-outputs:
	@if test '$(IMTHEINSTRUCTOR)' != true ; \
	then \
		echo 'Students should use the target check-outputs,' ; \
		echo 'as using this target (create-outputs) will invalidate the tests' ; \
		exit 1; \
	fi; \
	for f in `echo $(NONDECLTESTS) $(DECLTESTS) | sed -e 's/\\.$(SUF)//g'`; \
	do \
		echo running unparser on "$$f.$(SUF)"; \
		$(RM) "$$f.upo"; \
		./$(UNPARSER) "$$f.$(SUF)" >"$$f.upo" 2>&1; \
	done; \
	echo done creating unparser test outputs!

.PHONY: digest
digest: digest.txt

digest.txt: create-compiler-outputs
	for f in `ls $(GOODVMTESTS) | sed -e 's/\\.$(SUF)//g'` ; \
	do \
		cat $$f.$(SUF); \
		echo " "; cat $$f.out; \
		echo " "; echo " "; \
	done > digest.txt

unparser-digest.txt: create-unparser-outputs
	for f in `ls $(ALLTESTS) | sed -e 's/\\.$(SUF)//g'`; \
        do cat $$f.$(SUF); echo " "; cat $$f.upo; echo " "; echo " "; \
        done >unparser-digest.txt

# don't use outputs-clean unless you want to regenerate the expected outputs
.PHONY: develop-clean outputs-clean
outputs-clean:
	@if test '$(IMTHEINSTRUCTOR)' != true ; \
	then \
		echo 'Students should use the target clean,' ; \
		echo 'as using this target (develop-clean) will invalidate the tests'; \
		exit 1; \
	fi
	$(RM) *.out *.asm *.bof
	$(RM) digest.txt

develop-clean: clean
	@if test '$(IMTHEINSTRUCTOR)' != true ; \
	then \
		echo 'Students should use the target clean,' ; \
		echo 'as using this target (develop-clean) will invalidate the tests'; \
		exit 1; \
	fi
	$(RM) *.upo
	$(RM) digest.txt
	cd $(VM); make develop-clean

TESTSZIPFILE = ~/temp/hw3-tests.zip
PROVIDEDFILES = compiler_main.c utilities.[ch] lexer.[ch] unparser.[ch] \
		machine_types.h parser_types.h bison_pl0_y_top.y parser.[ch] \
		ast.[ch] file_location.[ch] id_attrs.[ch] id_use.[ch]

hw3-tests.zip: create-outputs $(TESTSZIPFILE)

$(TESTSZIPFILE): $(ALLTESTS) Makefile $(PROVIDEDFILES)
	$(RM) $(TESTSZIPFILE)
	chmod 444 $(ALLTESTS) $(EXPECTEDOUTPUTS) $(PROVIDEDFILES)
	chmod 744 Makefile
	$(ZIP) $(TESTSZIPFILE) $(ALLTESTS) $(EXPECTEDOUTPUTS) Makefile $(PROVIDEDFILES)

.PHONY: $(OVERALLZIPFILE)
$(OVERALLZIPFILE) ~/temp/$(OVERALLZIPFILE): Makefile *.[chly] *.pdf $(ALLTESTS)
	$(MAKE) clean create-outputs clean
	$(ZIP) ~/temp/$(OVERALLZIPFILE) $^ $(EXPECTEDOUTPUTS)

.PHONY: check-separately
check-separately: $(COMPILER_OBJECTS)

$(VM)/$(VM):
	cd $(VM); make vm

$(VM)/disasm:
	cd $(VM); make disasm

$(VM)/asm:
	cd $(VM); make asm

PDFLATEX = mpdflatex
BIBTEX = bibtex

.PRECIOUS: %.bib
%.bib: %.tex
	$(PDFLATEX) $< ; $(RM) `echo $@ | sed -e 's/.bib/.pdf/'`
	$(BIBTEX) `echo $@ | sed -e 's/.bib//'`

.PHONY: pdf
pdf: language-definition.pdf

%.pdf: %.tex # %.bib
	$(PDFLATEX) $<

.PHONY: check-separately
check-separately:
	$(CC) $(CFLAGS) -c *.c

all: $(COMPILER) $(VM)/$(VM) $(VM)/asm $(VM)/disasm
